---
author: "Naadiyaar"
title: "Chapter 1: Software And Software Engineering"
date: 2024-08-25
draft: false
ShowToc: true
---
## the nature of software
software delivers the most important product of our time, *information*
### defining software
changes introduces errors
### software application domains
#### system software
- service other programs
- process complex tasks
- compilers and editors
- usually get determinate data
- OSs and networking software
- usually get unstructured data
#### application software
- stand alone programs
- solves a business problem
- process business and technical data
#### engineering/scientific software
- data science programs
- analyzing numbers and graphs
- used in automotive stress testing, astronomy, volcano-logy
- used in generic analysis and meteorology
#### embedded software
- resides other programs
- used in systems to control functions and features for user and system itself
- doing both simple and complex tasks
#### product-line software
- composed of reusable parts.
- Designed to provide capabilities used by many customers.
- used for limited tasks like inventory control.
#### web/mobile applications
- wide verity of programs
- network centeric
- browser based, cloud computing
#### artificial intelligence
- solving complex problems that doesn't resolve by normal approaches
- make use of heuristics to solve complex problemas

it's not uncommon to work on software that is older than yourself
## defining the discipline
> the application of systematic, disciplines, quantifiable approach to the development, operation, and maintenance of software; that is, the application of engineering to software.

![software engineering layers](/software-engineering/software-engineering-layers.png)

> the bedrock that supports software engineering is a quality focus.
> the foundation for software engineering is the process layer.
> methods provides the technical how-to's for building software.
> tools provide automated or semi-automated support for the *process* and *methods*.
## the software process
collection of works that must be done to finish a work.
SE is an adoptable approach.
### The process framework
a process framework is foundation of SE. it defines a small number of activies that are aplicable to any SP, huge or small and used across the entire SP.
#### There are (usually) 5 general activities
- **communication**

Before anything, discussions must happen with stakeholders to understand the product objectives, features and functions

- **planning**  
a software engineering plan, defines technical task that must be conducted, risks that are likely, requariments that must be fullfiled, products that must be produced and schedules.

- **Modeling**  
Helps us better understand the problem and find solutions.

- **Construction**  
Build what you modeled. It involves both generating and testing code.

- **Deployment**  
Software as an entity, must be delivred to customer and receive feedback.

These can be used for any kind of software project.
These activities repeats and each complete repeat produces a *software increment*.

### Umbrella Activities
help the team to manage control, progress, change, risk.
#### Typically include...
- software project tracking and control
- risk management
- software quality assurance
- technical reviews
- measurement  
collects process, project and product measures that assist the team in delivering software that meets needs.
- software configuration management  
manages effects of changes

- re-usability management

- work product preparation and production

### process adaption
Software process is different among different teams and projects.

## software engineering practice
### the essence of practice from the old book *how to solve it*
- understand the problem (communication and analysis)
- plan a solution (modeling and design)
- carry out the plan (code generation)
- examine the result for accuracy (testing and quality assurance)

### Hooker's software engineering principles
1. the reason it all exists  
a software exist to provide value to its users

2. KISS (keep it simple stupid)  
result of it is a more maintainable and error-prone software

3. maintain the vision  
a clear vision is essential

4. what you produce, other will consume  
Don't give them reason to curse you!

5. be open to the future  
keep asking yourself "what if" be prepared for answer

6. plan ahead for reuse
reusable parts decreases expenses and overhead for future people but increases them for current state.

7. Think!

## How it all starts
Every software project exitst to serve a need.  
Need to adapt a legacy system, need to deliver a new feature, need to change business environment and etc.
